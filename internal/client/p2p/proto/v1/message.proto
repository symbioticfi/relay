syntax = "proto3";

package internal.client.p2p.proto.v1;

option go_package = "github.com/symbioticfi/relay/internal/client/p2p/proto/v1";

// AggregationProof represents the aggregation proof data
message AggregationProof {
  uint32 verification_type = 1;
  bytes message_hash = 2;
  bytes proof = 3;
}

// SignaturesAggregated represents the aggregated signatures message
message SignaturesAggregated {
  bytes request_hash = 1;  // 32 bytes fixed length
  uint32 key_tag = 2;
  uint64 epoch = 3;
  AggregationProof aggregation_proof = 4;
}

// Signature represents individual signature data
message Signature {
  bytes message_hash = 1;
  bytes signature = 2;
  bytes public_key = 3;
}

// SignatureGenerated represents the signature generated message
message SignatureGenerated {
  bytes request_hash = 1;  // 32 bytes fixed length
  uint32 key_tag = 2;
  uint64 epoch = 3;
  Signature signature = 4;
}

// P2PMessage represents a peer-to-peer message wrapper
message P2PMessage {
  string sender = 1;
  int64 timestamp = 2;
  bytes data = 3;
}

service SymbioticP2PService {
  rpc WantSignatures(WantSignaturesRequest) returns (WantSignaturesResponse);
  rpc WantAggregationProofs(WantAggregationProofsRequest) returns (WantAggregationProofsResponse);

}

message WantSignaturesRequest {
  // Map of request hash to bitmap of wanted validator indices
  map<string, bytes> want_signatures = 1;  // key: hex string of common.Hash, value: roaring bitmap bytes
}

message WantSignaturesResponse {
  // Map of request hash to list of validator signatures
  map<string, ValidatorSignatureList> signatures = 2;  // key: hex string of common.Hash
}


// ValidatorSignatureList contains a list of validator signatures for a specific request
message ValidatorSignatureList {
  repeated ValidatorSignature signatures = 1;
}

// ValidatorSignature pairs a signature with its validator index
message ValidatorSignature {
  uint32 validator_index = 1;
  SignatureExtended signature = 2;
}

// SignatureExtended represents extended signature data
message SignatureExtended {
  bytes message_hash = 1;
  bytes signature = 2;
  bytes public_key = 3;
}

message WantAggregationProofsRequest {
  // List of request hashes for which aggregation proofs are needed
  repeated string request_hashes = 1;  // hex strings of common.Hash
}

message WantAggregationProofsResponse {
  // Map of request hash to aggregation proof
  map<string, AggregationProof> proofs = 1;  // key: hex string of common.Hash
}

