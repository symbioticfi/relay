syntax = "proto3";

package internal.client.p2p.proto.v1;

option go_package = "github.com/symbioticfi/relay/internal/client/p2p/proto/v1";

// SignaturesAggregated represents the aggregated signatures message
message AggregationProof {
  uint32 key_tag = 2;
  uint64 epoch = 3;
  bytes message_hash = 4;
  bytes proof = 5;
}

// P2PMessage represents a peer-to-peer message wrapper
message P2PMessage {
  string sender = 1;
  int64 timestamp = 2;
  bytes data = 3;
}

service SymbioticP2PService {
  rpc WantSignatures(WantSignaturesRequest) returns (WantSignaturesResponse);
  rpc WantAggregationProofs(WantAggregationProofsRequest) returns (WantAggregationProofsResponse);

}

message WantSignaturesRequest {
  // Map of request id to bitmap of wanted validator indices
  map<string, bytes> want_signatures = 1;  // key: hex string of common.Hash, value: roaring bitmap bytes
}

message WantSignaturesResponse {
  // Map of request id to list of validator signatures
  map<string, ValidatorSignatureList> signatures = 2;  // key: hex string of common.Hash
}


// ValidatorSignatureList contains a list of validator signatures for a specific request
message ValidatorSignatureList {
  repeated ValidatorSignature signatures = 1;
}

// ValidatorSignature pairs a signature with its validator index
message ValidatorSignature {
  uint32 validator_index = 1;
  Signature signature = 2;
}

// Signature represents extended signature data
message Signature {
  bytes message_hash = 1;
  uint32 key_tag = 2;
  uint64 epoch = 3;
  bytes signature = 4;
  bytes public_key = 5;
}

message WantAggregationProofsRequest {
  // List of request ids for which aggregation proofs are needed
  repeated string request_ids = 1;  // hex strings of common.Hash
}

message WantAggregationProofsResponse {
  // Map of request ids to aggregation proof
  map<string, AggregationProof> proofs = 1;  // key: hex string of common.Hash
}

