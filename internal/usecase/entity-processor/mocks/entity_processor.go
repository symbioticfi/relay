// Code generated by MockGen. DO NOT EDIT.
// Source: entity_processor.go
//
// Generated by this command:
//
//	mockgen -source=entity_processor.go -destination=mocks/entity_processor.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	common "github.com/ethereum/go-ethereum/common"
	entity "github.com/symbioticfi/relay/symbiotic/entity"
	gomock "go.uber.org/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
	isgomock struct{}
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// GetAggregationProof mocks base method.
func (m *MockRepository) GetAggregationProof(ctx context.Context, epoch entity.Epoch, requestID common.Hash) (entity.AggregationProof, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAggregationProof", ctx, epoch, requestID)
	ret0, _ := ret[0].(entity.AggregationProof)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAggregationProof indicates an expected call of GetAggregationProof.
func (mr *MockRepositoryMockRecorder) GetAggregationProof(ctx, epoch, requestID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAggregationProof", reflect.TypeOf((*MockRepository)(nil).GetAggregationProof), ctx, epoch, requestID)
}

// GetSignatureByIndex mocks base method.
func (m *MockRepository) GetSignatureByIndex(ctx context.Context, epoch entity.Epoch, requestID common.Hash, validatorIndex uint32) (entity.Signature, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSignatureByIndex", ctx, epoch, requestID, validatorIndex)
	ret0, _ := ret[0].(entity.Signature)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSignatureByIndex indicates an expected call of GetSignatureByIndex.
func (mr *MockRepositoryMockRecorder) GetSignatureByIndex(ctx, epoch, requestID, validatorIndex any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSignatureByIndex", reflect.TypeOf((*MockRepository)(nil).GetSignatureByIndex), ctx, epoch, requestID, validatorIndex)
}

// GetValidatorByKey mocks base method.
func (m *MockRepository) GetValidatorByKey(ctx context.Context, epoch entity.Epoch, keyTag entity.KeyTag, publicKey []byte) (entity.Validator, uint32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetValidatorByKey", ctx, epoch, keyTag, publicKey)
	ret0, _ := ret[0].(entity.Validator)
	ret1, _ := ret[1].(uint32)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetValidatorByKey indicates an expected call of GetValidatorByKey.
func (mr *MockRepositoryMockRecorder) GetValidatorByKey(ctx, epoch, keyTag, publicKey any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValidatorByKey", reflect.TypeOf((*MockRepository)(nil).GetValidatorByKey), ctx, epoch, keyTag, publicKey)
}

// GetValidatorSetByEpoch mocks base method.
func (m *MockRepository) GetValidatorSetByEpoch(ctx context.Context, epoch entity.Epoch) (entity.ValidatorSet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetValidatorSetByEpoch", ctx, epoch)
	ret0, _ := ret[0].(entity.ValidatorSet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetValidatorSetByEpoch indicates an expected call of GetValidatorSetByEpoch.
func (mr *MockRepositoryMockRecorder) GetValidatorSetByEpoch(ctx, epoch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValidatorSetByEpoch", reflect.TypeOf((*MockRepository)(nil).GetValidatorSetByEpoch), ctx, epoch)
}

// SaveProof mocks base method.
func (m *MockRepository) SaveProof(ctx context.Context, aggregationProof entity.AggregationProof) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveProof", ctx, aggregationProof)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveProof indicates an expected call of SaveProof.
func (mr *MockRepositoryMockRecorder) SaveProof(ctx, aggregationProof any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveProof", reflect.TypeOf((*MockRepository)(nil).SaveProof), ctx, aggregationProof)
}

// SaveSignature mocks base method.
func (m *MockRepository) SaveSignature(ctx context.Context, signature entity.Signature, validator entity.Validator, activeIndex uint32) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveSignature", ctx, signature, validator, activeIndex)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveSignature indicates an expected call of SaveSignature.
func (mr *MockRepositoryMockRecorder) SaveSignature(ctx, signature, validator, activeIndex any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveSignature", reflect.TypeOf((*MockRepository)(nil).SaveSignature), ctx, signature, validator, activeIndex)
}

// MockAggregator is a mock of Aggregator interface.
type MockAggregator struct {
	ctrl     *gomock.Controller
	recorder *MockAggregatorMockRecorder
	isgomock struct{}
}

// MockAggregatorMockRecorder is the mock recorder for MockAggregator.
type MockAggregatorMockRecorder struct {
	mock *MockAggregator
}

// NewMockAggregator creates a new mock instance.
func NewMockAggregator(ctrl *gomock.Controller) *MockAggregator {
	mock := &MockAggregator{ctrl: ctrl}
	mock.recorder = &MockAggregatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggregator) EXPECT() *MockAggregatorMockRecorder {
	return m.recorder
}

// Verify mocks base method.
func (m *MockAggregator) Verify(valset entity.ValidatorSet, keyTag entity.KeyTag, aggregationProof entity.AggregationProof) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Verify", valset, keyTag, aggregationProof)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Verify indicates an expected call of Verify.
func (mr *MockAggregatorMockRecorder) Verify(valset, keyTag, aggregationProof any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Verify", reflect.TypeOf((*MockAggregator)(nil).Verify), valset, keyTag, aggregationProof)
}

// MockAggProofSignal is a mock of AggProofSignal interface.
type MockAggProofSignal struct {
	ctrl     *gomock.Controller
	recorder *MockAggProofSignalMockRecorder
	isgomock struct{}
}

// MockAggProofSignalMockRecorder is the mock recorder for MockAggProofSignal.
type MockAggProofSignalMockRecorder struct {
	mock *MockAggProofSignal
}

// NewMockAggProofSignal creates a new mock instance.
func NewMockAggProofSignal(ctrl *gomock.Controller) *MockAggProofSignal {
	mock := &MockAggProofSignal{ctrl: ctrl}
	mock.recorder = &MockAggProofSignalMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggProofSignal) EXPECT() *MockAggProofSignalMockRecorder {
	return m.recorder
}

// Emit mocks base method.
func (m *MockAggProofSignal) Emit(payload entity.AggregationProof) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Emit", payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// Emit indicates an expected call of Emit.
func (mr *MockAggProofSignalMockRecorder) Emit(payload any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Emit", reflect.TypeOf((*MockAggProofSignal)(nil).Emit), payload)
}
