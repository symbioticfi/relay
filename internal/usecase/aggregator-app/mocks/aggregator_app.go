// Code generated by MockGen. DO NOT EDIT.
// Source: aggregator_app.go
//
// Generated by this command:
//
//	mockgen -source=aggregator_app.go -destination=mocks/aggregator_app.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	common "github.com/ethereum/go-ethereum/common"
	entity "github.com/symbioticfi/relay/internal/entity"
	entity0 "github.com/symbioticfi/relay/symbiotic/entity"
	crypto "github.com/symbioticfi/relay/symbiotic/usecase/crypto"
	gomock "go.uber.org/mock/gomock"
)

// Mockrepository is a mock of repository interface.
type Mockrepository struct {
	ctrl     *gomock.Controller
	recorder *MockrepositoryMockRecorder
	isgomock struct{}
}

// MockrepositoryMockRecorder is the mock recorder for Mockrepository.
type MockrepositoryMockRecorder struct {
	mock *Mockrepository
}

// NewMockrepository creates a new mock instance.
func NewMockrepository(ctrl *gomock.Controller) *Mockrepository {
	mock := &Mockrepository{ctrl: ctrl}
	mock.recorder = &MockrepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockrepository) EXPECT() *MockrepositoryMockRecorder {
	return m.recorder
}

// GetAggregationProof mocks base method.
func (m *Mockrepository) GetAggregationProof(ctx context.Context, epoch entity0.Epoch, requestID common.Hash) (entity0.AggregationProof, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAggregationProof", ctx, epoch, requestID)
	ret0, _ := ret[0].(entity0.AggregationProof)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAggregationProof indicates an expected call of GetAggregationProof.
func (mr *MockrepositoryMockRecorder) GetAggregationProof(ctx, epoch, requestID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAggregationProof", reflect.TypeOf((*Mockrepository)(nil).GetAggregationProof), ctx, epoch, requestID)
}

// GetAllSignatures mocks base method.
func (m *Mockrepository) GetAllSignatures(ctx context.Context, epoch entity0.Epoch, requestID common.Hash) ([]entity0.Signature, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllSignatures", ctx, epoch, requestID)
	ret0, _ := ret[0].([]entity0.Signature)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllSignatures indicates an expected call of GetAllSignatures.
func (mr *MockrepositoryMockRecorder) GetAllSignatures(ctx, epoch, requestID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllSignatures", reflect.TypeOf((*Mockrepository)(nil).GetAllSignatures), ctx, epoch, requestID)
}

// GetConfigByEpoch mocks base method.
func (m *Mockrepository) GetConfigByEpoch(ctx context.Context, epoch entity0.Epoch) (entity0.NetworkConfig, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetConfigByEpoch", ctx, epoch)
	ret0, _ := ret[0].(entity0.NetworkConfig)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetConfigByEpoch indicates an expected call of GetConfigByEpoch.
func (mr *MockrepositoryMockRecorder) GetConfigByEpoch(ctx, epoch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConfigByEpoch", reflect.TypeOf((*Mockrepository)(nil).GetConfigByEpoch), ctx, epoch)
}

// GetSignatureMap mocks base method.
func (m *Mockrepository) GetSignatureMap(ctx context.Context, requestID common.Hash) (entity.SignatureMap, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSignatureMap", ctx, requestID)
	ret0, _ := ret[0].(entity.SignatureMap)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSignatureMap indicates an expected call of GetSignatureMap.
func (mr *MockrepositoryMockRecorder) GetSignatureMap(ctx, requestID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSignatureMap", reflect.TypeOf((*Mockrepository)(nil).GetSignatureMap), ctx, requestID)
}

// GetSignatureRequest mocks base method.
func (m *Mockrepository) GetSignatureRequest(arg0 context.Context, requestID common.Hash) (entity0.SignatureRequest, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSignatureRequest", arg0, requestID)
	ret0, _ := ret[0].(entity0.SignatureRequest)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSignatureRequest indicates an expected call of GetSignatureRequest.
func (mr *MockrepositoryMockRecorder) GetSignatureRequest(arg0, requestID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSignatureRequest", reflect.TypeOf((*Mockrepository)(nil).GetSignatureRequest), arg0, requestID)
}

// GetValidatorSetByEpoch mocks base method.
func (m *Mockrepository) GetValidatorSetByEpoch(ctx context.Context, epoch entity0.Epoch) (entity0.ValidatorSet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetValidatorSetByEpoch", ctx, epoch)
	ret0, _ := ret[0].(entity0.ValidatorSet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetValidatorSetByEpoch indicates an expected call of GetValidatorSetByEpoch.
func (mr *MockrepositoryMockRecorder) GetValidatorSetByEpoch(ctx, epoch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValidatorSetByEpoch", reflect.TypeOf((*Mockrepository)(nil).GetValidatorSetByEpoch), ctx, epoch)
}

// Mockp2pClient is a mock of p2pClient interface.
type Mockp2pClient struct {
	ctrl     *gomock.Controller
	recorder *Mockp2pClientMockRecorder
	isgomock struct{}
}

// Mockp2pClientMockRecorder is the mock recorder for Mockp2pClient.
type Mockp2pClientMockRecorder struct {
	mock *Mockp2pClient
}

// NewMockp2pClient creates a new mock instance.
func NewMockp2pClient(ctrl *gomock.Controller) *Mockp2pClient {
	mock := &Mockp2pClient{ctrl: ctrl}
	mock.recorder = &Mockp2pClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockp2pClient) EXPECT() *Mockp2pClientMockRecorder {
	return m.recorder
}

// BroadcastSignatureAggregatedMessage mocks base method.
func (m *Mockp2pClient) BroadcastSignatureAggregatedMessage(ctx context.Context, proof entity0.AggregationProof) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BroadcastSignatureAggregatedMessage", ctx, proof)
	ret0, _ := ret[0].(error)
	return ret0
}

// BroadcastSignatureAggregatedMessage indicates an expected call of BroadcastSignatureAggregatedMessage.
func (mr *Mockp2pClientMockRecorder) BroadcastSignatureAggregatedMessage(ctx, proof any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BroadcastSignatureAggregatedMessage", reflect.TypeOf((*Mockp2pClient)(nil).BroadcastSignatureAggregatedMessage), ctx, proof)
}

// Mockmetrics is a mock of metrics interface.
type Mockmetrics struct {
	ctrl     *gomock.Controller
	recorder *MockmetricsMockRecorder
	isgomock struct{}
}

// MockmetricsMockRecorder is the mock recorder for Mockmetrics.
type MockmetricsMockRecorder struct {
	mock *Mockmetrics
}

// NewMockmetrics creates a new mock instance.
func NewMockmetrics(ctrl *gomock.Controller) *Mockmetrics {
	mock := &Mockmetrics{ctrl: ctrl}
	mock.recorder = &MockmetricsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockmetrics) EXPECT() *MockmetricsMockRecorder {
	return m.recorder
}

// ObserveAppAggregateDuration mocks base method.
func (m *Mockmetrics) ObserveAppAggregateDuration(d time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ObserveAppAggregateDuration", d)
}

// ObserveAppAggregateDuration indicates an expected call of ObserveAppAggregateDuration.
func (mr *MockmetricsMockRecorder) ObserveAppAggregateDuration(d any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ObserveAppAggregateDuration", reflect.TypeOf((*Mockmetrics)(nil).ObserveAppAggregateDuration), d)
}

// ObserveOnlyAggregateDuration mocks base method.
func (m *Mockmetrics) ObserveOnlyAggregateDuration(d time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ObserveOnlyAggregateDuration", d)
}

// ObserveOnlyAggregateDuration indicates an expected call of ObserveOnlyAggregateDuration.
func (mr *MockmetricsMockRecorder) ObserveOnlyAggregateDuration(d any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ObserveOnlyAggregateDuration", reflect.TypeOf((*Mockmetrics)(nil).ObserveOnlyAggregateDuration), d)
}

// Mockaggregator is a mock of aggregator interface.
type Mockaggregator struct {
	ctrl     *gomock.Controller
	recorder *MockaggregatorMockRecorder
	isgomock struct{}
}

// MockaggregatorMockRecorder is the mock recorder for Mockaggregator.
type MockaggregatorMockRecorder struct {
	mock *Mockaggregator
}

// NewMockaggregator creates a new mock instance.
func NewMockaggregator(ctrl *gomock.Controller) *Mockaggregator {
	mock := &Mockaggregator{ctrl: ctrl}
	mock.recorder = &MockaggregatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockaggregator) EXPECT() *MockaggregatorMockRecorder {
	return m.recorder
}

// Aggregate mocks base method.
func (m *Mockaggregator) Aggregate(valset entity0.ValidatorSet, keyTag entity0.KeyTag, messageHash []byte, signatures []entity0.Signature) (entity0.AggregationProof, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Aggregate", valset, keyTag, messageHash, signatures)
	ret0, _ := ret[0].(entity0.AggregationProof)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Aggregate indicates an expected call of Aggregate.
func (mr *MockaggregatorMockRecorder) Aggregate(valset, keyTag, messageHash, signatures any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Aggregate", reflect.TypeOf((*Mockaggregator)(nil).Aggregate), valset, keyTag, messageHash, signatures)
}

// MockkeyProvider is a mock of keyProvider interface.
type MockkeyProvider struct {
	ctrl     *gomock.Controller
	recorder *MockkeyProviderMockRecorder
	isgomock struct{}
}

// MockkeyProviderMockRecorder is the mock recorder for MockkeyProvider.
type MockkeyProviderMockRecorder struct {
	mock *MockkeyProvider
}

// NewMockkeyProvider creates a new mock instance.
func NewMockkeyProvider(ctrl *gomock.Controller) *MockkeyProvider {
	mock := &MockkeyProvider{ctrl: ctrl}
	mock.recorder = &MockkeyProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockkeyProvider) EXPECT() *MockkeyProviderMockRecorder {
	return m.recorder
}

// GetOnchainKeyFromCache mocks base method.
func (m *MockkeyProvider) GetOnchainKeyFromCache(keyTag entity0.KeyTag) (entity0.CompactPublicKey, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOnchainKeyFromCache", keyTag)
	ret0, _ := ret[0].(entity0.CompactPublicKey)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOnchainKeyFromCache indicates an expected call of GetOnchainKeyFromCache.
func (mr *MockkeyProviderMockRecorder) GetOnchainKeyFromCache(keyTag any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOnchainKeyFromCache", reflect.TypeOf((*MockkeyProvider)(nil).GetOnchainKeyFromCache), keyTag)
}

// GetPrivateKey mocks base method.
func (m *MockkeyProvider) GetPrivateKey(keyTag entity0.KeyTag) (crypto.PrivateKey, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPrivateKey", keyTag)
	ret0, _ := ret[0].(crypto.PrivateKey)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPrivateKey indicates an expected call of GetPrivateKey.
func (mr *MockkeyProviderMockRecorder) GetPrivateKey(keyTag any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPrivateKey", reflect.TypeOf((*MockkeyProvider)(nil).GetPrivateKey), keyTag)
}
