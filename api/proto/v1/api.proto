syntax = "proto3";

package api.proto.v1;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/symbioticfi/relay/api/proto/v1";

// SymbioticAPI provides access to the Symbiotic relay functions
service SymbioticAPIService {
  // Sign a message
  rpc SignMessage(SignMessageRequest) returns (SignMessageResponse);

  // Get aggregation proof
  rpc GetAggregationProof(GetAggregationProofRequest) returns (GetAggregationProofResponse);

  // Get current epoch
  rpc GetCurrentEpoch(GetCurrentEpochRequest) returns (GetCurrentEpochResponse);

  // Get signature by request id
  rpc GetSignatures(GetSignaturesRequest) returns (GetSignaturesResponse);

  // Get signature request by signature id
  rpc GetSignatureRequest(GetSignatureRequestRequest) returns (GetSignatureRequestResponse);

  // Get aggregation status, can be sent only to aggregator nodes
  rpc GetAggregationStatus(GetAggregationStatusRequest) returns (GetAggregationStatusResponse);

  // Get current validator set
  rpc GetValidatorSet(GetValidatorSetRequest) returns (GetValidatorSetResponse);

  // Get validator by address
  rpc GetValidatorByAddress(GetValidatorByAddressRequest) returns (GetValidatorByAddressResponse);

  // Get validator set header
  rpc GetValidatorSetHeader(GetValidatorSetHeaderRequest) returns (GetValidatorSetHeaderResponse);

  // Sign a message and wait for aggregation proof via stream
  rpc SignMessageWait(SignMessageWaitRequest) returns (stream SignMessageWaitResponse);

  // Get last committed epoch for a specific settlement chain
  rpc GetLastCommitted(GetLastCommittedRequest) returns (GetLastCommittedResponse);

  // Get last committed epochs for all settlement chains
  rpc GetLastAllCommitted(GetLastAllCommittedRequest) returns (GetLastAllCommittedResponse);

  // Get validator set metadata like extra data and request id to fetch aggregation and signature requests
  rpc GetValidatorSetMetadata(GetValidatorSetMetadataRequest) returns (GetValidatorSetMetadataResponse);
}

// Request message for signing a message
message SignMessageRequest {
  // Key tag identifier (0-127)
  uint32 key_tag = 1;

  // Message to be signed
  bytes message = 2;

  // Required epoch (optional, if not provided latest committed epoch will be used)
  optional uint64 required_epoch = 3;
}

// Request message for signing a message
message SignMessageWaitRequest {
  // Key tag identifier (0-127)
  uint32 key_tag = 1;

  // Message to be signed
  bytes message = 2;

  // Required epoch (optional, if not provided latest committed epoch will be used)
  optional uint64 required_epoch = 3;
}

// Response message for sign message request
message SignMessageResponse {
  // Hash of the signature request
  string request_id = 1;

  // Epoch number
  uint64 epoch = 2;
}

// Streaming response message for sign message wait
message SignMessageWaitResponse {
  // Current status of the signing process
  SigningStatus status = 1;

  // Id of the request
  string request_id = 2;

  // Epoch number
  uint64 epoch = 3;

  // Final aggregation proof (only set when status is SIGNING_STATUS_COMPLETED)
  optional AggregationProof aggregation_proof = 6;
}

// Request message for getting aggregation proof
message GetAggregationProofRequest {
  string request_id = 1;
}

// Request message for getting current epoch
message GetCurrentEpochRequest {}

// Request message for getting signatures
message GetSignaturesRequest {
  string request_id = 1;
}

// Response message for getting signatures
message GetSignaturesResponse {
  // List of signatures
  repeated Signature signatures = 1;
}

// Request message for getting signature request
message GetSignatureRequestRequest {
  string request_id = 1;
}

// Request message for getting aggregation status
message GetAggregationStatusRequest {
  string request_id = 1;
}

// Request message for getting validator set
message GetValidatorSetRequest {
  // Epoch number (optional, if not provided current epoch will be used)
  optional uint64 epoch = 1;
}

// Request message for getting validator by address
message GetValidatorByAddressRequest {
  // Epoch number (optional, if not provided current epoch will be used)
  optional uint64 epoch = 1;

  // Validator address (required)
  string address = 2;
}

// Request message for getting validator set header
message GetValidatorSetHeaderRequest {
  // Epoch number (optional, if not provided current epoch will be used)
  optional uint64 epoch = 1;
}

// Request message for getting validator set metadata
message GetValidatorSetMetadataRequest {
  // Epoch number (optional, if not provided current epoch will be used)
  optional uint64 epoch = 1;
}

// Response message for getting current epoch
message GetCurrentEpochResponse {
  // Epoch number
  uint64 epoch = 1;

  // Epoch start time
  google.protobuf.Timestamp start_time = 2;
}

// Response message for getting signature request
message GetSignatureRequestResponse {
  // Key tag identifier (0-127)
  uint32 key_tag = 1;

  // Message to be signed
  bytes message = 2;

  // Required epoch
  uint64 required_epoch = 3;
}

// Response message for getting aggregation proof
message GetAggregationProofResponse {
  AggregationProof aggregation_proof = 1;
}

// Response message for getting aggregation proof
message AggregationProof {
  // Message hash
  bytes message_hash = 2;

  // Proof data
  bytes proof = 3;
}

// Response message for getting aggregation status
message GetAggregationStatusResponse {
  // Current voting power of the aggregator (big integer as string)
  string current_voting_power = 1;

  // List of operator addresses that signed the request
  repeated string signer_operators = 2;
}

// Digital signature
message Signature {
  // Signature data
  bytes signature = 1;

  // Message hash
  bytes message_hash = 2;

  // Public key
  bytes public_key = 3;
}

// Response message for getting validator set
message GetValidatorSetResponse {
  // Version of the validator set
  uint32 version = 1;

  // Key tag required to commit next validator set
  uint32 required_key_tag = 2;

  // Validator set epoch
  uint64 epoch = 3;

  // Epoch capture timestamp
  google.protobuf.Timestamp capture_timestamp = 4;

  // Quorum threshold (big integer as string)
  string quorum_threshold = 5;

  // Status of validator set header
  ValidatorSetStatus status = 6;

  // List of validators
  repeated Validator validators = 7;
}

// Response message for getting validator by address
message GetValidatorByAddressResponse {
  // The validator
  Validator validator = 1;
}

message ExtraData {
  bytes key = 1;
  bytes value = 2;
}

// Response message for getting validator set header
message GetValidatorSetMetadataResponse {
  repeated ExtraData extra_data = 1;
  bytes commitment_data = 2;
  string request_id = 3;
}

// Response message for getting validator set header
message GetValidatorSetHeaderResponse {
  // Version of the validator set
  uint32 version = 1;

  // Key tag required to commit next validator set
  uint32 required_key_tag = 2;

  // Validator set epoch
  uint64 epoch = 3;

  // Epoch capture timestamp
  google.protobuf.Timestamp capture_timestamp = 4;

  // Quorum threshold (big integer as string)
  string quorum_threshold = 5;

  // Total voting power (big integer as string)
  string total_voting_power = 6;

  // Validators SSZ Merkle root (hex string)
  string validators_ssz_mroot = 7;
}

// Validator set status enumeration
enum ValidatorSetStatus {
  // Default/unknown status
  VALIDATOR_SET_STATUS_UNSPECIFIED = 0;

  // Derived status
  VALIDATOR_SET_STATUS_DERIVED = 1;

  // Aggregated status
  VALIDATOR_SET_STATUS_AGGREGATED = 2;

  // Committed status
  VALIDATOR_SET_STATUS_COMMITTED = 3;
}

// Validator information
message Validator {
  // Operator address (hex string)
  string operator = 1;

  // Voting power of the validator (big integer as string)
  string voting_power = 2;

  // Indicates if the validator is active
  bool is_active = 3;

  // List of cryptographic keys
  repeated Key keys = 4;

  // List of validator vaults
  repeated ValidatorVault vaults = 5;
}

// Cryptographic key
message Key {
  // Key tag identifier (0-127)
  uint32 tag = 1;

  // Key payload
  bytes payload = 2;
}

// Validator vault information
message ValidatorVault {
  // Chain identifier
  uint64 chain_id = 1;

  // Vault address
  string vault = 2;

  // Voting power for this vault (big integer as string)
  string voting_power = 3;
}


// Signing process status enumeration
enum SigningStatus {
  // Default/unknown status
  SIGNING_STATUS_UNSPECIFIED = 0;

  // Request has been created and is waiting for signatures
  SIGNING_STATUS_PENDING = 1;

  // Signing process completed successfully with proof
  SIGNING_STATUS_COMPLETED = 2;

  // Signing process failed
  SIGNING_STATUS_FAILED = 3;

  // Signing request timed out
  SIGNING_STATUS_TIMEOUT = 4;
}

// Error code enumeration
enum ErrorCode {
  // Default/unknown error
  ERROR_CODE_UNSPECIFIED = 0;

  // No data found
  ERROR_CODE_NO_DATA = 1;

  // Internal server error
  ERROR_CODE_INTERNAL = 2;

  // Not an aggregator node
  ERROR_CODE_NOT_AGGREGATOR = 3;
}

// Request message for getting last committed epoch for a specific settlement chain
message GetLastCommittedRequest {
  // Settlement chain ID
  uint64 settlement_chain_id = 1;
}

// Response message for getting last committed epoch
message GetLastCommittedResponse {
  // Settlement chain ID
  uint64 settlement_chain_id = 1;
  ChainEpochInfo  epoch_info = 2;
}

// Request message for getting last committed epochs for all chains
message GetLastAllCommittedRequest {
  // No parameters needed
}

// Response message for getting all last committed epochs
message GetLastAllCommittedResponse {
  // List of settlement chains with their last committed epochs
  map<uint64, ChainEpochInfo> epoch_infos = 1;
}

// Settlement chain with its last committed epoch
message ChainEpochInfo {
  // Last committed epoch for this chain
  uint64 last_committed_epoch = 1;

  // Epoch start time
  google.protobuf.Timestamp start_time = 2;
}
