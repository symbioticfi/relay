package main

// generate-client-types is a tool to parse the generated protobuf file and create a client types file
// that exports types for client usage, including enums, requests, responses, and data types.

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"regexp"
	"sort"
	"strings"
)

const clientTemplate = `// Code generated by generate-client-types. DO NOT EDIT.
package v1

import (
	apiv1 "github.com/symbioticfi/relay/internal/gen/api/v1"
)

// Exported types for client usage

%s
`

type TypeInfo struct {
	Name      string
	Category  string
	IsEnum    bool
	Constants []string
}

func main() {
	// Parse the generated protobuf file
	genFile := "internal/gen/api/v1/api.pb.go"

	if len(os.Args) > 1 {
		genFile = os.Args[1]
	}

	types, err := parseGeneratedFile(genFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing generated file: %v\n", err)
		os.Exit(1)
	}

	// Generate the client file content
	content := generateClientContent(types)

	// Write to client file
	clientFile := "api/client/v1/types.go"
	if len(os.Args) > 2 {
		clientFile = os.Args[2]
	}

	err = os.WriteFile(clientFile, []byte(content), 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error writing client file: %v\n", err)
		os.Exit(1)
	}

	fmt.Fprintf(os.Stdout, "Generated client types in %s\n", clientFile)
}

func parseGeneratedFile(filename string) ([]TypeInfo, error) {
	// Read the file content
	content, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %w", err)
	}

	// Parse using AST
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, content, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse file: %w", err)
	}

	var types []TypeInfo

	// Walk the AST to find type declarations
	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.GenDecl:
			if x.Tok == token.TYPE {
				for _, spec := range x.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						typeName := typeSpec.Name.Name

						// Skip internal/private types
						if !isExportedType(typeName) {
							continue
						}

						typeInfo := TypeInfo{Name: typeName}

						// Determine type category and if it's an enum
						switch typeSpec.Type.(type) {
						case *ast.Ident:
							// Check if it's an enum (int32 type)
							if ident, ok := typeSpec.Type.(*ast.Ident); ok && ident.Name == "int32" {
								typeInfo.IsEnum = true
								typeInfo.Category = "enum"
								typeInfo.Constants = findEnumConstants(string(content), typeName)
							}
						case *ast.StructType:
							typeInfo.Category = categorizeStruct(typeName)
						}

						if typeInfo.Category != "" {
							types = append(types, typeInfo)
						}
					}
				}
			}
		}
		return true
	})

	return types, nil
}

func isExportedType(typeName string) bool {
	// Skip internal protobuf types and unexported types
	if strings.HasPrefix(typeName, "file_") ||
		strings.HasPrefix(typeName, "xxx_") ||
		strings.Contains(typeName, "Descriptor") ||
		len(typeName) == 0 ||
		strings.ToUpper(string(typeName[0])) != string(typeName[0]) {
		return false
	}
	return true
}

func categorizeStruct(typeName string) string {
	if strings.HasSuffix(typeName, "Request") {
		return "request"
	} else if strings.HasSuffix(typeName, "Response") {
		return "response"
	} else if strings.Contains(typeName, "Error") {
		return "response" // ErrorResponse goes with responses
	} else {
		return "data"
	}
}

func findEnumConstants(content, enumName string) []string {
	var constants []string

	// Use regex to find enum constants
	pattern := fmt.Sprintf(`%s_(\w+)\s+%s\s*=`, enumName, enumName)
	re := regexp.MustCompile(pattern)

	matches := re.FindAllStringSubmatch(content, -1)
	for _, match := range matches {
		if len(match) > 1 {
			constants = append(constants, fmt.Sprintf("%s_%s", enumName, match[1]))
		}
	}

	return constants
}

func generateClientContent(types []TypeInfo) string {
	var sections []string

	// Group types by category
	enums := make([]TypeInfo, 0)
	requests := make([]TypeInfo, 0)
	responses := make([]TypeInfo, 0)
	dataTypes := make([]TypeInfo, 0)

	for _, t := range types {
		switch t.Category {
		case "enum":
			enums = append(enums, t)
		case "request":
			requests = append(requests, t)
		case "response":
			responses = append(responses, t)
		case "data":
			dataTypes = append(dataTypes, t)
		}
	}

	// Sort each category
	sort.Slice(enums, func(i, j int) bool { return enums[i].Name < enums[j].Name })
	sort.Slice(requests, func(i, j int) bool { return requests[i].Name < requests[j].Name })
	sort.Slice(responses, func(i, j int) bool { return responses[i].Name < responses[j].Name })
	sort.Slice(dataTypes, func(i, j int) bool { return dataTypes[i].Name < dataTypes[j].Name })

	// Generate enums section
	if len(enums) > 0 {
		sections = append(sections, "// Enums")
		for _, enum := range enums {
			sections = append(sections, fmt.Sprintf("type %s = apiv1.%s", enum.Name, enum.Name))
		}

		// Generate enum constants
		if hasEnumConstants(enums) {
			sections = append(sections, "")
			sections = append(sections, "// Enum constants")
			sections = append(sections, "const (")

			for i, enum := range enums {
				if len(enum.Constants) > 0 {
					if i > 0 {
						sections = append(sections, "")
					}
					sections = append(sections, fmt.Sprintf("\t// %s values", enum.Name))
					for _, constant := range enum.Constants {
						sections = append(sections, fmt.Sprintf("\t%s = apiv1.%s", constant, constant))
					}
				}
			}
			sections = append(sections, ")")
		}
	}

	// Generate request types section
	if len(requests) > 0 {
		sections = append(sections, "")
		sections = append(sections, "// Request types")
		for _, req := range requests {
			sections = append(sections, fmt.Sprintf("type %s = apiv1.%s", req.Name, req.Name))
		}
	}

	// Generate response types section
	if len(responses) > 0 {
		sections = append(sections, "")
		sections = append(sections, "// Response types")
		for _, resp := range responses {
			sections = append(sections, fmt.Sprintf("type %s = apiv1.%s", resp.Name, resp.Name))
		}
	}

	// Generate data types section
	if len(dataTypes) > 0 {
		sections = append(sections, "")
		sections = append(sections, "// Data types")
		for _, data := range dataTypes {
			sections = append(sections, fmt.Sprintf("type %s = apiv1.%s", data.Name, data.Name))
		}
	}

	typeExports := strings.Join(sections, "\n")
	return fmt.Sprintf(clientTemplate, typeExports)
}

func hasEnumConstants(enums []TypeInfo) bool {
	for _, enum := range enums {
		if len(enum.Constants) > 0 {
			return true
		}
	}
	return false
}
