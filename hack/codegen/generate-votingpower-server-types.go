package main

// generate-votingpower-server-types parses generated protobuf definitions and creates
// exported type aliases for server package usage.

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"sort"
	"strings"
)

const serverTemplate = `// Code generated by generate-votingpower-server-types. DO NOT EDIT.
package v1

import (
	votingpowerv1 "github.com/symbioticfi/relay/internal/gen/votingpower/v1"
)

// Exported types for server usage

%s
`

type typeInfo struct {
	name     string
	category string
}

func main() {
	genFile := "internal/gen/votingpower/v1/votingpower.pb.go"
	if len(os.Args) > 1 {
		genFile = os.Args[1]
	}

	types, err := parseGeneratedFile(genFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing generated file: %v\n", err)
		os.Exit(1)
	}

	content := generateServerContent(types)

	outputFile := "votingpower/server/v1/types.go"
	if len(os.Args) > 2 {
		outputFile = os.Args[2]
	}

	if err := os.WriteFile(outputFile, []byte(content), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing server types file: %v\n", err)
		os.Exit(1)
	}

	fmt.Fprintf(os.Stdout, "Generated votingpower server types in %s\n", outputFile)
}

func parseGeneratedFile(filename string) ([]typeInfo, error) {
	content, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %w", err)
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, content, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse file: %w", err)
	}

	var types []typeInfo
	ast.Inspect(node, func(n ast.Node) bool {
		decl, ok := n.(*ast.GenDecl)
		if !ok || decl.Tok != token.TYPE {
			return true
		}

		for _, spec := range decl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			typeName := typeSpec.Name.Name
			if !isExportedType(typeName) {
				continue
			}

			category := categorizeType(typeName)
			if category == "" {
				continue
			}

			types = append(types, typeInfo{name: typeName, category: category})
		}

		return true
	})

	return types, nil
}

func isExportedType(typeName string) bool {
	if strings.HasPrefix(typeName, "file_") ||
		strings.HasPrefix(typeName, "xxx_") ||
		strings.Contains(typeName, "Descriptor") ||
		len(typeName) == 0 ||
		strings.ToUpper(string(typeName[0])) != string(typeName[0]) {
		return false
	}
	return true
}

func categorizeType(typeName string) string {
	switch {
	case strings.HasSuffix(typeName, "Request"):
		return "request"
	case strings.HasSuffix(typeName, "Response"):
		return "response"
	default:
		return "data"
	}
}

func generateServerContent(types []typeInfo) string {
	requests := make([]typeInfo, 0)
	responses := make([]typeInfo, 0)
	data := make([]typeInfo, 0)

	for _, t := range types {
		switch t.category {
		case "request":
			requests = append(requests, t)
		case "response":
			responses = append(responses, t)
		default:
			data = append(data, t)
		}
	}

	sort.Slice(requests, func(i, j int) bool { return requests[i].name < requests[j].name })
	sort.Slice(responses, func(i, j int) bool { return responses[i].name < responses[j].name })
	sort.Slice(data, func(i, j int) bool { return data[i].name < data[j].name })

	lines := make([]string, 0)

	if len(requests) > 0 {
		lines = append(lines, "// Request types")
		for _, item := range requests {
			lines = append(lines, fmt.Sprintf("type %s = votingpowerv1.%s", item.name, item.name))
		}
	}

	if len(responses) > 0 {
		lines = append(lines, "")
		lines = append(lines, "// Response types")
		for _, item := range responses {
			lines = append(lines, fmt.Sprintf("type %s = votingpowerv1.%s", item.name, item.name))
		}
	}

	if len(data) > 0 {
		lines = append(lines, "")
		lines = append(lines, "// Data types")
		for _, item := range data {
			lines = append(lines, fmt.Sprintf("type %s = votingpowerv1.%s", item.name, item.name))
		}
	}

	return fmt.Sprintf(serverTemplate, strings.Join(lines, "\n"))
}
