# Symbiotic Relay

## Overview

Symbiotic Relay is a peer-to-peer side-network designed to collect and aggregate signatures from validators, maintain validator sets (valsets) on settlement contract.

This service facilitates efficient signature collection and aggregation in a decentralized manner.

## Repo init

This repo uses submodule with git-lfs for circuits testing keys, so make sure to install it first:

```bash
brew install git-lfs
git lfs install
```

Clone

```bash
git clone --recurse-submodules git@github.com:symbioticfi/relay.git
```

Download lfs files

```bash
cd relay-bn254-example-circuit-keys
git lfs pull # for all files download, long download
git lfs pull --include="circuit_10.pk,circuit_10.r1cs,circuit_10.vk" # enough for testing
```

Then check that file content are downloaded

```bash
head -c 100 relay-bn254-example-circuit-keys/circuit_10.r1cs
```

## Create env configuration

```bash
cp .env.example .env
```

Key parameters:

- `OPERATORS` - num of operators in network
- `VERIFICATION_TYPE` - signatures aggregation type, (0 for ZK, 1 for simple)

## On-chain setup

Before running off-chain nodes need to setup on-chain contract.

To simplify local development we've prepared docker image with anvil node and deployed Symbiotic contracts.

NOTES: 
 - use repo https://github.com/symbioticfi/middleware-sdk-mirror
 - use branch `stable`, commit: `8c8c5aefdc3cdaa6729cb49fccaefb4499e7e3b8`

### Build docker image

```bash
cd [PUT_ONCHAIN_DIR_PATH]
git checkout stable
docker build -t symbiotic-anvil .
cd ..
```

### Run anvil node

```bash
docker run --rm -d -p 8545:8545 --env-file .env --name symbiotic-node symbiotic-anvil
```

### Configure network

```bash
docker run --rm -it --env-file .env --network host symbiotic-anvil yarn deploy:network
```

This command will execute list of transactions to setup network contracts

In execution logs you can see deployed configuration and contract addresses.

## Running side-cars (side-network)

The application supports 3 modes:

- Signer: reponsible only for signing
- Aggregator: responsible for signature agggregation
- Committer: responsible for new valset header commitment

### Build off-chain

```bash
go mod tidy
go build -o relay_sidecar ./cmd/relay_sidecar
```

### Running node 1 (signer only)

```bash
./relay_sidecar --driver.chain-id 111 --driver.address 0xA65C4ca1b06BD89aC03A395b3cA0919bF5F58869 --chains-id 111 --chains-rpc-url http://127.0.0.1:8545 --log-level info --log-mode pretty --secret-key 1000000000000000000 --signer true --http-listen :8081
```

### Running node 2 (signer + committer)

```bash
./relay_sidecar --driver.chain-id 111 --driver.address 0xA65C4ca1b06BD89aC03A395b3cA0919bF5F58869 --chains-id 111 --chains-rpc-url http://127.0.0.1:8545 --log-level info --log-mode pretty --secret-key 1000000000000000001 --signer true --committer true --http-listen :8082
```

### Running node 3 (signer + aggregator)

```bash
./relay_sidecar --driver.chain-id 111 --driver.address 0xA65C4ca1b06BD89aC03A395b3cA0919bF5F58869 --chains-id 111 --chains-rpc-url http://127.0.0.1:8545 --log-level info --log-mode pretty --secret-key 1000000000000000002 --signer true --aggregator true --http-listen :8083 --circuits-dir relay-bn254-example-circuit-keys
```

Notes:

- After all nodes are up and running it might take a few minutes/seconds to catch up
- In committer log (node 2) you can see `valset header committed` which means that valset header committed on-chain
- In aggregator logs (node 3) you can see aggregation proof generation details
- If you want to see more details re-run nodes with `--log-level debug`

## Running testing client application

For testing purposes we've prepared simple application that:

- ask to sign random data from nodes
- wait until aggregated signature is generated by network
- check aggregation proof usign on-chain contract
- log result

### Build application

```bash
go build -o msg-sign ./cmd/msg-sign
```

### Stop anvil node

```bash
docker stop symbiotic-node
```

## Running utils application

For utility functions we provided `utils` binary that:
- manages keys with encrypted keystore (list, add, remove, update)

### Build application

```bash
go build -o utils ./cmd/utils
```

### Run application

```bash
./utils --help
```
