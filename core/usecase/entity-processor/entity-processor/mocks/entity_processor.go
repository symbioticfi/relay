// Code generated by MockGen. DO NOT EDIT.
// Source: entity_processor.go
//
// Generated by this command:
//
//	mockgen -source=entity_processor.go -destination=mocks/entity_processor.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	entity "github.com/symbioticfi/relay/core/entity"
	gomock "go.uber.org/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
	isgomock struct{}
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// AddProof mocks base method.
func (m *MockRepository) AddProof(ctx context.Context, aggregationProof entity.AggregationProof) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddProof", ctx, aggregationProof)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddProof indicates an expected call of AddProof.
func (mr *MockRepositoryMockRecorder) AddProof(ctx, aggregationProof any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddProof", reflect.TypeOf((*MockRepository)(nil).AddProof), ctx, aggregationProof)
}

// AddSignature mocks base method.
func (m *MockRepository) AddSignature(ctx context.Context, signature entity.SignatureExtended) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddSignature", ctx, signature)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddSignature indicates an expected call of AddSignature.
func (mr *MockRepositoryMockRecorder) AddSignature(ctx, signature any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSignature", reflect.TypeOf((*MockRepository)(nil).AddSignature), ctx, signature)
}

// GetValidatorSetByEpoch mocks base method.
func (m *MockRepository) GetValidatorSetByEpoch(ctx context.Context, epoch entity.Epoch) (entity.ValidatorSet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetValidatorSetByEpoch", ctx, epoch)
	ret0, _ := ret[0].(entity.ValidatorSet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetValidatorSetByEpoch indicates an expected call of GetValidatorSetByEpoch.
func (mr *MockRepositoryMockRecorder) GetValidatorSetByEpoch(ctx, epoch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValidatorSetByEpoch", reflect.TypeOf((*MockRepository)(nil).GetValidatorSetByEpoch), ctx, epoch)
}

// MockAggregator is a mock of Aggregator interface.
type MockAggregator struct {
	ctrl     *gomock.Controller
	recorder *MockAggregatorMockRecorder
	isgomock struct{}
}

// MockAggregatorMockRecorder is the mock recorder for MockAggregator.
type MockAggregatorMockRecorder struct {
	mock *MockAggregator
}

// NewMockAggregator creates a new mock instance.
func NewMockAggregator(ctrl *gomock.Controller) *MockAggregator {
	mock := &MockAggregator{ctrl: ctrl}
	mock.recorder = &MockAggregatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggregator) EXPECT() *MockAggregatorMockRecorder {
	return m.recorder
}

// Verify mocks base method.
func (m *MockAggregator) Verify(valset entity.ValidatorSet, keyTag entity.KeyTag, aggregationProof entity.AggregationProof) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Verify", valset, keyTag, aggregationProof)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Verify indicates an expected call of Verify.
func (mr *MockAggregatorMockRecorder) Verify(valset, keyTag, aggregationProof any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Verify", reflect.TypeOf((*MockAggregator)(nil).Verify), valset, keyTag, aggregationProof)
}

// MockAggProofSignal is a mock of AggProofSignal interface.
type MockAggProofSignal struct {
	ctrl     *gomock.Controller
	recorder *MockAggProofSignalMockRecorder
	isgomock struct{}
}

// MockAggProofSignalMockRecorder is the mock recorder for MockAggProofSignal.
type MockAggProofSignalMockRecorder struct {
	mock *MockAggProofSignal
}

// NewMockAggProofSignal creates a new mock instance.
func NewMockAggProofSignal(ctrl *gomock.Controller) *MockAggProofSignal {
	mock := &MockAggProofSignal{ctrl: ctrl}
	mock.recorder = &MockAggProofSignalMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggProofSignal) EXPECT() *MockAggProofSignalMockRecorder {
	return m.recorder
}

// Emit mocks base method.
func (m *MockAggProofSignal) Emit(payload entity.AggregationProof) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Emit", payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// Emit indicates an expected call of Emit.
func (mr *MockAggProofSignalMockRecorder) Emit(payload any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Emit", reflect.TypeOf((*MockAggProofSignal)(nil).Emit), payload)
}
